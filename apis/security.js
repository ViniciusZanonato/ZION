// ===================================================================
// üîê M√ìDULO DE VIGIL√ÇNCIA DIGITAL - ZION SUPREMO
// Implementa√ß√£o de APIs de seguran√ßa e monitoramento digital
// ===================================================================

const fetch = require('node-fetch');
const crypto = require('crypto');
const chalk = require('chalk');
const boxen = require('boxen');
const ora = require('ora');
const Table = require('cli-table3');

class SecurityModule {
    constructor() {
        this.name = 'VIGIL√ÇNCIA DIGITAL';
        this.description = 'Monitoramento de seguran√ßa e an√°lise de vulnerabilidades';
        this.hibpApiUrl = 'https://haveibeenpwned.com/api/v3';
    }

    // Have I Been Pwned - Verificar vazamentos de dados
    async checkEmailBreaches(email) {
        const spinner = ora(chalk.red(`üîç Analisando vazamentos de dados para: ${email}...`)).start();
        
        try {
            const url = `${this.hibpApiUrl}/breachedaccount/${encodeURIComponent(email)}?truncateResponse=false`;
            
            const response = await fetch(url, {
                headers: {
                    'User-Agent': 'ZION-Security-Scanner/1.0',
                    'Accept': 'application/json'
                }
            });
            
            if (response.status === 404) {
                spinner.succeed(chalk.green('‚úÖ Nenhum vazamento detectado nos bancos de dados'));
                console.log(boxen(
                    chalk.green.bold('üõ°Ô∏è STATUS: SEGURO\n') +
                    chalk.white(`üìß Email: ${email}\n`) +
                    chalk.green('‚úÖ N√£o foram encontrados vazamentos de dados\n') +
                    chalk.gray('üîç An√°lise baseada em dados p√∫blicos de vazamentos'),
                    {
                        padding: 1,
                        borderColor: 'green',
                        title: 'üîí RELAT√ìRIO DE SEGURAN√áA'
                    }
                ));
                return [];
            }
            
            if (!response.ok) {
                throw new Error(`Erro na consulta: ${response.status}`);
            }
            
            const breaches = await response.json();
            spinner.succeed(chalk.yellow(`‚ö†Ô∏è ${breaches.length} vazamento(s) detectado(s)`));
            
            this.displayBreachReport(email, breaches);
            return breaches;
            
        } catch (error) {
            spinner.fail(chalk.red('FALHA NA AN√ÅLISE DE SEGURAN√áA'));
            console.log(chalk.red(`‚ùå Erro: ${error.message}`));
            return null;
        }
    }

    // Exibir relat√≥rio detalhado de vazamentos
    displayBreachReport(email, breaches) {
        const table = new Table({
            head: [chalk.red('VAZAMENTO'), chalk.yellow('DATA'), chalk.cyan('DADOS EXPOSTOS'), chalk.magenta('SEVERIDADE')],
            colWidths: [25, 12, 40, 12]
        });
        
        breaches.forEach(breach => {
            const severity = this.calculateSeverity(breach);
            const dataTypes = breach.DataClasses ? breach.DataClasses.join(', ') : 'N/A';
            const date = new Date(breach.BreachDate).toLocaleDateString('pt-BR');
            
            table.push([
                chalk.white(breach.Name),
                chalk.white(date),
                chalk.white(dataTypes.substring(0, 35) + (dataTypes.length > 35 ? '...' : '')),
                this.getSeverityColor(severity)
            ]);
        });
        
        console.log(boxen(
            chalk.red.bold('üö® VAZAMENTOS DE DADOS DETECTADOS\n') +
            chalk.yellow(`üìß Email: ${email}\n`) +
            chalk.white(`üìä Total de vazamentos: ${breaches.length}\n`) +
            chalk.gray('üîç An√°lise baseada em dados p√∫blicos de vazamentos'),
            {
                padding: 1,
                borderColor: 'red',
                title: '‚ö†Ô∏è ALERTA DE SEGURAN√áA'
            }
        ));
        
        console.log('\n' + table.toString());
        
        // Recomenda√ß√µes de seguran√ßa
        this.showSecurityRecommendations(breaches);
    }

    // Calcular severidade do vazamento
    calculateSeverity(breach) {
        let score = 0;
        
        if (breach.DataClasses) {
            const sensitiveData = ['Passwords', 'Email addresses', 'Phone numbers', 'Credit cards', 'Social security numbers'];
            breach.DataClasses.forEach(dataClass => {
                if (sensitiveData.includes(dataClass)) {
                    score += 2;
                } else {
                    score += 1;
                }
            });
        }
        
        if (breach.IsVerified) score += 1;
        if (breach.IsSensitive) score += 2;
        
        if (score >= 8) return 'CR√çTICA';
        if (score >= 5) return 'ALTA';
        if (score >= 3) return 'M√âDIA';
        return 'BAIXA';
    }

    // Colorir severidade
    getSeverityColor(severity) {
        switch(severity) {
            case 'CR√çTICA': return chalk.red.bold(severity);
            case 'ALTA': return chalk.red(severity);
            case 'M√âDIA': return chalk.yellow(severity);
            case 'BAIXA': return chalk.green(severity);
            default: return chalk.gray(severity);
        }
    }

    // Verificar senhas comprometidas (SHA-1)
    async checkPasswordPwned(password) {
        const spinner = ora(chalk.red('üîê Verificando integridade da senha...')).start();
        
        try {
            // Gerar hash SHA-1 da senha
            const sha1Hash = crypto.createHash('sha1').update(password).digest('hex').toUpperCase();
            const prefix = sha1Hash.substring(0, 5);
            const suffix = sha1Hash.substring(5);
            
            const url = `https://api.pwnedpasswords.com/range/${prefix}`;
            
            const response = await fetch(url, {
                headers: {
                    'User-Agent': 'ZION-Security-Scanner/1.0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`Erro na consulta: ${response.status}`);
            }
            
            const data = await response.text();
            const hashes = data.split('\n');
            
            for (const hash of hashes) {
                const [hashSuffix, count] = hash.split(':');
                if (hashSuffix === suffix) {
                    spinner.fail(chalk.red('‚ö†Ô∏è SENHA COMPROMETIDA'));
                    console.log(boxen(
                        chalk.red.bold('üö® ALERTA DE SEGURAN√áA\n') +
                        chalk.yellow('üîì Sua senha foi encontrada em vazamentos de dados\n') +
                        chalk.white(`üìä Apari√ß√µes: ${parseInt(count).toLocaleString()} vezes\n`) +
                        chalk.red('‚ö†Ô∏è RECOMENDA√á√ÉO: Altere sua senha imediatamente'),
                        {
                            padding: 1,
                            borderColor: 'red',
                            title: 'üíÄ SENHA COMPROMETIDA'
                        }
                    ));
                    return { compromised: true, count: parseInt(count) };
                }
            }
            
            spinner.succeed(chalk.green('‚úÖ Senha n√£o encontrada em vazamentos'));
            console.log(boxen(
                chalk.green.bold('üõ°Ô∏è STATUS: SEGURA\n') +
                chalk.white('üîê Sua senha n√£o foi encontrada em vazamentos p√∫blicos\n') +
                chalk.green('‚úÖ Continue usando pr√°ticas seguras de senha'),
                {
                    padding: 1,
                    borderColor: 'green',
                    title: 'üîí SENHA SEGURA'
                }
            ));
            
            return { compromised: false, count: 0 };
            
        } catch (error) {
            spinner.fail(chalk.red('FALHA NA VERIFICA√á√ÉO DE SENHA'));
            console.log(chalk.red(`‚ùå Erro: ${error.message}`));
            return null;
        }
    }

    // Mostrar recomenda√ß√µes de seguran√ßa
    showSecurityRecommendations(breaches) {
        const recommendations = [
            'üîê Altere senhas de contas afetadas imediatamente',
            'üîë Use senhas √∫nicas para cada servi√ßo',
            'üì± Ative autentica√ß√£o de dois fatores (2FA)',
            'üìß Monitore suas contas regularmente',
            'üõ°Ô∏è Use um gerenciador de senhas confi√°vel',
            'üîç Verifique regularmente por vazamentos'
        ];
        
        console.log(boxen(
            chalk.cyan.bold('üõ°Ô∏è RECOMENDA√á√ïES DE SEGURAN√áA\n') +
            recommendations.map(rec => chalk.white(rec)).join('\n'),
            {
                padding: 1,
                borderColor: 'cyan',
                title: 'üí° DICAS DE PROTE√á√ÉO'
            }
        ));
    }

    // An√°lise de for√ßa da senha
    analyzePasswordStrength(password) {
        let score = 0;
        const analysis = {
            length: password.length,
            hasLower: /[a-z]/.test(password),
            hasUpper: /[A-Z]/.test(password),
            hasNumbers: /\d/.test(password),
            hasSymbols: /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password),
            strength: 'MUITO FRACA'
        };
        
        // Pontua√ß√£o baseada em crit√©rios
        if (analysis.length >= 8) score += 2;
        if (analysis.length >= 12) score += 1;
        if (analysis.hasLower) score += 1;
        if (analysis.hasUpper) score += 1;
        if (analysis.hasNumbers) score += 1;
        if (analysis.hasSymbols) score += 2;
        
        // Determinar for√ßa da senha
        if (score >= 7) analysis.strength = 'MUITO FORTE';
        else if (score >= 5) analysis.strength = 'FORTE';
        else if (score >= 3) analysis.strength = 'M√âDIA';
        else if (score >= 1) analysis.strength = 'FRACA';
        
        return analysis;
    }

    // Gerar relat√≥rio completo de seguran√ßa
    async generateSecurityReport(email, password = null) {
        console.log(chalk.red.bold('\nüîç INICIANDO AN√ÅLISE COMPLETA DE SEGURAN√áA...\n'));
        
        const breaches = await this.checkEmailBreaches(email);
        let passwordAnalysis = null;
        
        if (password) {
            console.log('\n');
            passwordAnalysis = await this.checkPasswordPwned(password);
            
            console.log('\n');
            const strengthAnalysis = this.analyzePasswordStrength(password);
            this.displayPasswordStrengthReport(strengthAnalysis);
        }
        
        return {
            email,
            breaches,
            passwordAnalysis
        };
    }

    // Exibir relat√≥rio de for√ßa da senha
    displayPasswordStrengthReport(analysis) {
        const strengthColor = {
            'MUITO FORTE': chalk.green.bold,
            'FORTE': chalk.green,
            'M√âDIA': chalk.yellow,
            'FRACA': chalk.red,
            'MUITO FRACA': chalk.red.bold
        };
        
        console.log(boxen(
            chalk.cyan.bold('üîê AN√ÅLISE DE FOR√áA DA SENHA\n') +
            chalk.white(`üìè Comprimento: ${analysis.length} caracteres\n`) +
            chalk.white(`üî§ Min√∫sculas: ${analysis.hasLower ? '‚úÖ' : '‚ùå'}\n`) +
            chalk.white(`üî† Mai√∫sculas: ${analysis.hasUpper ? '‚úÖ' : '‚ùå'}\n`) +
            chalk.white(`üî¢ N√∫meros: ${analysis.hasNumbers ? '‚úÖ' : '‚ùå'}\n`) +
            chalk.white(`üî£ S√≠mbolos: ${analysis.hasSymbols ? '‚úÖ' : '‚ùå'}\n`) +
            `\nüéØ FOR√áA: ${strengthColor[analysis.strength](analysis.strength)}`,
            {
                padding: 1,
                borderColor: 'cyan',
                title: 'üí™ FOR√áA DA SENHA'
            }
        ));
    }
}

module.exports = SecurityModule;

